<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on A Crazy Cat</title><link>https://www.offf.xyz/categories/c++/</link><description>Recent content in c++ on A Crazy Cat</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 08 Jan 2019 23:37:21 +0800</lastBuildDate><atom:link href="https://www.offf.xyz/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>c++ noncopyable 类</title><link>https://www.offf.xyz/cpp-noncopyable/</link><pubDate>Tue, 08 Jan 2019 23:37:21 +0800</pubDate><guid>https://www.offf.xyz/cpp-noncopyable/</guid><description>一、noncopyable类作用 当类实现者不想让调用者拷贝或赋值构造类对象时，继承noncopyable类可达到此目的。
二、noncopyable类实现 class noncopyable { protected: noncopyable() {} ~noncopyable() {} private: noncopyable(const noncopyable&amp;amp;); const noncopyable&amp;amp; operator=(const noncopyable&amp;amp;); }; // c++11 实现方法 class noncopyable { protected: noncopyable() = default; ~noncopyable() = default; private: noncopyable(const noncopyable&amp;amp;) = delete; const noncopyable&amp;amp; operator=(const noncopyable&amp;amp;) = delete; }; 三、原理 派生类调用拷贝构造函数或赋值构造函数时， 会调用基类(noncopyable)的拷贝构造函数或赋值构造函数
class A : public noncopyable { public: A(int i) { i_ = i; } private: int i_; }; //调用 A a1(55); A a2(a1); //error;</description></item></channel></rss>